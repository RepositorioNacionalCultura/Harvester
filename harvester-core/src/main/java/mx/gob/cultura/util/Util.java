package mx.gob.cultura.util;

import com.carrotsearch.hppc.CharSet;
import com.mongodb.BasicDBList;
import com.mongodb.BasicDBObject;
import com.mongodb.DBCollection;
import com.mongodb.DBCursor;
import com.mongodb.DBObject;
import com.mongodb.MongoClient;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;
import java.nio.charset.Charset;
import org.apache.http.HttpHost;
import org.apache.log4j.Logger;
import org.elasticsearch.action.index.IndexRequest;
import org.elasticsearch.action.index.IndexResponse;
import org.elasticsearch.client.RestClient;
import org.elasticsearch.client.RestHighLevelClient;

import org.elasticsearch.common.UUIDs;
import org.elasticsearch.common.xcontent.XContentType;
import org.elasticsearch.rest.RestStatus;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

import org.semanticwb.datamanager.DataList;
import org.semanticwb.datamanager.DataObject;
import org.semanticwb.datamanager.SWBDataSource;
import org.semanticwb.datamanager.SWBScriptEngine;

/**
 * Utility class with common methods.
 *
 * @author Hasdai Pacheco
 */
public final class Util {
    private static final Logger log = Logger.getLogger(Util.class);

    private Util() {
    }

    /**
     * Inner class to encapsulate methods related to DataBase actions.
     */
    public static final class DB {

        private static HashMap<String, MongoClient> mongoClients = new HashMap<>();
        private static HashMap<String, RestHighLevelClient> elasticClients = new HashMap<>();

        /**
         * Gets a {@link MongoClient} instance with default host and port.
         *
         * @return MongoClient instance object.
         */
        public static MongoClient getMongoClient() {
            return getMongoClient("localhost", 27017);
        }

        /**
         * Gets a {@link MongoClient} instance with given host and port.
         *
         * @param host MongoDB server host.
         * @param port MongoDB server port.
         * @return MongoClient instance object.
         */
        public static MongoClient getMongoClient(String host, int port) {
            MongoClient ret = mongoClients.get(host + ":" + String.valueOf(port));
            if (null == ret) {
                ret = new MongoClient(host, port);
                mongoClients.put(host + ":" + String.valueOf(port), ret);
            }
            return ret;
        }

        /**
         * Gets a {@link RestHighLevelClient} instance with default host and
         * port.
         *
         * @return RestHighLevelClient instance object.
         */
        public static RestHighLevelClient getElasticClient() {
            return getElasticClient("localhost", 9200);
        }

        /**
         * Gets a {@link RestHighLevelClient} instance with given host and port.
         *
         * @param host ElasticSearch node host name.
         * @param port ElasticSearch node port.
         * @return RestHighLevelClient instance object.
         */
        public static RestHighLevelClient getElasticClient(String host, int port) {
            RestHighLevelClient ret = elasticClients.get(host + ":" + String.valueOf(port));
            if (null == ret) {
                ret = new RestHighLevelClient(
                        RestClient.builder(new HttpHost(host, port)));

                elasticClients.put(host + ":" + String.valueOf(port), ret);
            }
            return ret;
        }

        /**
         * Gets time-based UUID for indexing objects.
         *
         * @return String representation of a time-based UUID.
         */
        public static String getUUID() {
            return UUIDs.base64UUID();
        }

        /**
         * Indexes an object in ElasticSearch.
         *
         * @param client {@link RestHighLevelClient} object.
         * @param indexName Name of index to use.
         * @param typeName Name of type in index.
         * @param objectId ID for object, autogenerated if null.
         * @param objectJson Object content in JSON String format.
         * @return ID of indexed object or null if indexing fails.
         */
        public static String indexObject(RestHighLevelClient client, String indexName, String typeName, String objectId, String objectJson) {
            String ret = null;
            String id = objectId;

            if (null == objectId || objectId.isEmpty()) {
                id = Util.DB.getUUID();
            }

            IndexRequest req = new IndexRequest(indexName, typeName, id);
            req.source(objectJson, XContentType.JSON);

            try {
                IndexResponse resp = client.index(req);
                if (resp.status().getStatus() == RestStatus.CREATED.getStatus()
                        || resp.status().getStatus() == RestStatus.OK.getStatus()) {
                    ret = resp.getId();
                }
            } catch (IOException ioex) {
                log.error("Error indexing object with ID " + objectId + " on index " + indexName, ioex);
            }

            return ret;
        }
    }

    /**
     * Transforma un DataObject a BasicDBObject
     *
     * @param obj DataObject recibido
     * @return El BasicJSONObject traducido desde un DataObject
     */
    public static BasicDBObject toBasicDBObject(DataObject obj) {

        BasicDBObject ret = new BasicDBObject();
        Iterator<Map.Entry<String, Object>> it = obj.entrySet().iterator();
        while (it.hasNext()) {
            Map.Entry<String, Object> entry = it.next();
            ret.put(entry.getKey(), toBasicDB(entry.getValue()));
        }
        return ret;
    }

    /**
     *
     * @param obj
     * @return
     */
    public static Object toBasicDB(Object obj) {
        if (obj instanceof DataObject) {
            return toBasicDBObject((DataObject) obj);
        } else if (obj instanceof DataList) {
            return toBasicDBList((DataList) obj);
        }
        return obj;
    }

    /**
     * Traduce un DataList a BasicDBList
     *
     * @param obj
     * @return
     */
    public static BasicDBList toBasicDBList(DataList obj) {
        BasicDBList ret = new BasicDBList();
        Iterator it = obj.iterator();
        while (it.hasNext()) {
            ret.add(toBasicDB(it.next()));
        }
        return ret;
    }

    /**
     * Carga la colección de Replace a un HashMap<ocurrencia, reemplazo>
     *
     * @param engine Utilizado para poder cargar la colección de Replace en un
     * HashMap
     * @return HashMap con DataSource cargado en memoria.
     */
    public static HashMap<String, String> loadOccurrences(SWBScriptEngine engine) {

        SWBDataSource datasource = null;
        HashMap<String, String> hm = new HashMap();

        if (null != engine) {
            try {
                datasource = engine.getDataSource("Replace");
                DataObject r = new DataObject();
                DataObject data = new DataObject();
                r.put("data", data);

                DataObject ret = datasource.fetch(r);
                String occurrence = "";
                String replace = "";

                DataList rdata = ret.getDataObject("response").getDataList("data");
                DataObject dobj = null;
                if (!rdata.isEmpty()) {
                    for (int i = 0; i < rdata.size(); i++) {
                        dobj = rdata.getDataObject(i);  // DataObject de Replace
                        occurrence = dobj.getString("occurrence");
                        replace = dobj.getString("replace");
                        hm.put(occurrence, replace);
                    }
                }
            } catch (Exception e) {
                log.error("Error al cargar el DataSource. ", e);
            }
        } else {
            log.error("Error al cargar el DataSource al HashMap, falta inicializar el engine.");
            return null;
        }

        return hm;
    }

    /**
     * Carga la colección de Prefijo de metadata a un
     * ConcurrentHashMap<identificador, DataObject>
     *
     * @param dbName Nombre de la base de datos en donde se encuentra la
     * colección
     * @param metadataPrefix Nombre del prefijo de metadatos a cargar
     * @return ConcurrentHashMap con la colección cargada en memoria.
     */
    public static ConcurrentHashMap<String, String> loadMetadataPrefixCollection(String dbName, String metadataPrefix) {

        ConcurrentHashMap<String, String> hm = new ConcurrentHashMap();
        MongoClient client = new MongoClient("localhost", 27017);
        com.mongodb.DB db = client.getDB(dbName.toUpperCase());

        if (null != db) {
            try {
                DBCollection datasource = db.getCollection(metadataPrefix);
                DBCursor cursor = datasource.find();
                //System.out.println(metadataPrefix + " cursor size: " + cursor.count());
                while (cursor.hasNext()) {
                    DBObject next = cursor.next();
                    String key = (String) next.get("oaiid");
//                    DataObject dataO = new DataObject();
//                    dataO.put("oaiid", key);
//                    dataO.put("body", next.get("body"));
                    hm.put(key.trim(), key);
                }
                //System.out.println("copiados al HM: " + hm.size());
            } catch (Exception e) {
                log.error("Error al cargar el DataSource. ", e);
            }
        } else {
//            System.out.println("Error al cargar el DataSource al HashMap, falta inicializar el engine.");
            return null;
        }
        return hm;
    }

    /**
     * Regresa el número de elementos en la colección long
     *
     * @param dbName Nombre de la base de datos en donde se encuentra la
     * colección
     * @param metadataPrefix Nombre del prefijo de metadatos a cargar
     * @return long con eltamaño de la colección.
     */
    public static long collectionSize(String dbName, String metadataPrefix) {

        long collSize = -1;
        //ConcurrentHashMap<String, DataObject> hm = new ConcurrentHashMap();
        MongoClient client = new MongoClient("localhost", 27017);
        com.mongodb.DB db = client.getDB(dbName.toUpperCase());

        if (null != db) {
            try {
                DBCollection datasource = db.getCollection(metadataPrefix);
                collSize = datasource.count();
            } catch (Exception e) {
                log.error("Error while trying to get collection size. ", e);
            }
        } else {
//            System.out.println("Error DB no encontrada.");
        }
        return collSize;
    }

    /**
     * Reemplaza las ocurrencias en el string recibido
     *
     * @param hm HashMap con las ocurrencias y su reemplazo previamente cargado
     * @param oaistr Stream del registro OAI a revisar
     * @return String con todas las ocurrencias reemplazadas.
     */
    public static String replaceOccurrences(HashMap<String, String> hm, String oaistr) {
        if (null != hm && null != oaistr) {
            String occurrence = "";
            String replace = "";
            Iterator<String> it = hm.keySet().iterator();
            while (it.hasNext()) {
                occurrence = it.next();
                replace = hm.get(occurrence);
                oaistr = oaistr.replace(occurrence, replace);
            }
        }
        return oaistr;
    }

    /**
     * Make the URL Request from the extractor
     *
     * @param theUrl La Url de la cual se extraeran los datos
     * @param XMLSupport Si soporta XML la llamada, o lo trae directamente en
     * JSON
     * @return Los datos traidos de la Url recibida
     */
    public static String makeRequest(URL theUrl, boolean XMLSupport) {
        HttpURLConnection con = null;
        StringBuilder response = new StringBuilder();
        String errorMsg = null;
        int retries = 0;
        boolean isConnOk = false;
        do {
            try {
                con = (HttpURLConnection) theUrl.openConnection();
                isConnOk = true;
                //AQUI SE PIDE EN XML
                if (XMLSupport) {
                    con.setRequestProperty("accept", "application/xml");
                }
                con.setRequestMethod("GET");

                int statusCode = con.getResponseCode();

                if (statusCode == 200) {
                    try (BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream(),Charset.forName("UTF-8")))) {
                        String inputLine;

                        while ((inputLine = in.readLine()) != null) {
                            response.append(inputLine);
                        }
                    } catch (IOException ioex) {
                        log.error(ioex);
                    }
                } else {
                    errorMsg = "#Error: No se puede conectar al servidor#";
                    throw new Exception();
                }

            } catch (Exception e) {
                if (null != con) {
                    con.disconnect();
                }
                retries++;
                try {
                    Thread.sleep(5000);
                } catch (Exception te) {
                    log.error(te);
                }

                log.error(e);
                isConnOk = false;
                if (retries == 5) {
                    errorMsg = "#Error: No se puede conectar al servidor#";
                }
            }
        } while (isConnOk == false && retries < 5);
        return errorMsg != null ? errorMsg : response.toString();
    }

    /**
     * Format milliseconds long number in days, hours, minutes, seconds and
     * milliseconds
     *
     * @param elapsedTime time to determinate in days, hours, minutes, seconds
     * and milliseconds takes.
     * @return a text in days, hours, minutes, seconds and milliseconds format
     */
    public static String getElapsedTime(long elapsedTime) {
        String etime = elapsedTime + "ms";
        long seg = 1000;
        long min = 60 * seg;
        long hr = 60 * min;
        long day = 24 * hr;

        long ndays = 0;
        long nhr = 0;
        long nmin = 0;
        long nseg = 0;
        long nms = 0;

        if (elapsedTime > day) {
            ndays = elapsedTime / day;
            if (ndays > 0 && (elapsedTime % day) > 0) {
                nhr = ((elapsedTime % day)) / hr;
            }
            if (nhr > 0 && (((elapsedTime % day)) % hr) > 0) {
                nmin = ((elapsedTime % day) % hr) / min;
            }
            if (nmin > 0 && (((elapsedTime % day) % hr) % min) > 0) {
                nseg = (((elapsedTime % day) % hr) % min) / seg;
            }
            if (nseg > 0 && ((((elapsedTime % day) % hr) % min) % seg) > 0) {
                nms = (((elapsedTime % day) % hr) % min) % seg;
            }

        } else if (elapsedTime > hr) {
            nhr = elapsedTime / hr;
            if (nhr > 0 && (elapsedTime % hr) > 0) {
                nmin = (elapsedTime % hr) / min;
            }
            if (nmin > 0 && ((elapsedTime % hr) % min) > 0) {
                nseg = ((elapsedTime % hr) % min) / seg;
            }
            if (nseg > 0 && (((elapsedTime % hr) % min) % seg) > 0) {
                nms = (((elapsedTime % hr) % min) % seg);
            }
        } else if (elapsedTime > min) {
            nmin = elapsedTime / min;
            if (nmin > 0 && (elapsedTime % min) > 0) {
                nseg = ((elapsedTime % min)) / seg;
            }
            if (nseg > 0 && (((elapsedTime % min) % seg)) > 0) {
                nms = ((elapsedTime % min) % seg);
            }

        } else if (elapsedTime > seg) {
            nseg = elapsedTime / seg;
        } else {
            nms = elapsedTime;
        }

        etime = "";
        if (ndays > 0) {
            etime = ndays + "dias ";
        }
        if (nhr > 0) {
            if (nhr < 10) {
                etime += "0" + nhr + "hrs ";
            } else {
                etime += nhr + "hrs ";
            }
        }
        if (nmin > 0) {
            if (nmin < 10) {
                etime += "0" + nmin + "min ";
            } else {
                etime += nmin + "min ";
            }
        }
        if (nseg > 0) {
            if (nseg < 10) {
                etime += "0" + nseg + "sec ";
            } else {
                etime += nseg + "sec ";
            }
        }
        if (nms > 0) {
            etime += nms + "ms";
        }

        return etime;
    }

    /**
     * Carga en el hm todas las propiedades del DataObject
     *
     * @param prop DataObject a revisar para obtener la lista de propiedades
     * existentes
     * @param propName Nombre de la propiedad actual que se revisa
     * @param hm HashMap con la lista de propiedades
     */
    private static void loadProps(DataObject prop, String propName, HashMap<String, String> hm) {
        Iterator<String> it = prop.keySet().iterator();
        while (it.hasNext()) {
            String next = it.next();
            Object obj = prop.get(next);
            String key = propName + "." + next;
            if (null != obj && obj instanceof DataObject) {
                loadProps((DataObject) obj, key, hm);
            } else {
                hm.put(key, key);
            }
        }
    }

    /**
     * Carga en el hm todas las propiedades del DataObject
     *
     * @param prop DataObject a revisar para obtener la lista de propiedades
     * existentes
     */
    public static HashMap<String, String> listProps(DataObject prop, HashMap<String, String> collection) {

        HashMap<String, String> hm = new HashMap();

        Iterator<String> it = prop.keySet().iterator();
        while (it.hasNext()) {
            String next1 = it.next();

            Object obj = prop.get(next1);
            if (null != obj && obj instanceof DataObject) {
                loadProps((DataObject) obj, next1, hm);
            } else {
                hm.put(next1, next1);
            }
        }
        return hm;
    }

    /**
     * Carga en el hm todas las propiedades del DataObject
     *
     * @param prop DataObject a revisar para obtener la lista de propiedades
     * existentes
     * @param propName Nombre de la propiedad actual que se revisa
     */
    private static void findProps(DataObject prop, String propName, HashMap<String, String> collection, SWBScriptEngine engine) {
        Iterator<String> it = prop.keySet().iterator();
        while (it.hasNext()) {
            String next = it.next();
            Object obj = prop.get(next);
            String key = propName + "." + next;
            if (null != obj && obj instanceof DataObject) {
                findProps((DataObject) obj, key, collection, engine);
            } else {
                //buscar propiedad en el hashmap 
                if (collection.get(propName) != null) {
                    // Sólo puede tener un valor
                    String coll2use = collection.get(propName);
                    SWBDataSource dscoll = engine.getDataSource(coll2use);

                    if (null != dscoll) {
                        try {
                            DataObject r = new DataObject();
                            DataObject data = new DataObject();
                            r.put("data", data);
                            data.put("value", obj);
                            DataObject ret = dscoll.fetch(r);
                            DataList rdata = ret.getDataObject("response").getDataList("data");
                            DataObject res = null;
                            if (!rdata.isEmpty()) {
                                String replaceValue = null;
                                for (int i = 0; i < rdata.size(); i++) {
                                    res = rdata.getDataObject(i);  // DataObject de Replace
                                    if (replaceValue == null) {
                                        replaceValue = "";
                                    }
                                    if (replaceValue.length() > 0) {
                                        replaceValue += ",";
                                    }
                                    replaceValue += res.getString("replace");
                                }
                                prop.put(next, replaceValue);
                            } else {
//                                System.out.println("No se encontró valor "+obj+" en la colección..."+coll2use);
                            }
                        } catch (Exception e) {
                            //No se encontró la propiedad con el valor actual
                            log.error("Error al buscar el valor en la colección", e);
                        }
                    }
                }
            }
        }
    }

    /**
     * MApeo de propiedades definidas en el DataObject transformado
     *
     * @param dobj DataObject para revisar propiedades y mapearlas en relación a
     * la tabla de mapeo definida en el mismo extractor
     * @param collection Tabla de mapeo cargada en un HashMap<String,String>
     * definida en el extractor
     * @param engine, para obtener el dataSource de la colección en donde se
     * buscará el valor a sustituir, si existe.
     */
    public static void findProps(DataObject dobj, HashMap<String, String> collection, SWBScriptEngine engine) {

        Iterator<String> it = dobj.keySet().iterator();
        while (it.hasNext()) {
            String next1 = it.next();

            Object obj = dobj.get(next1);
            if (null != obj && obj instanceof DataObject) {
                findProps((DataObject) obj, next1, collection, engine);
            } else {
                //buscar y actualizar propiedad
                //buscar propiedad en el hashmap 
//                System.out.println("Buscando propiedad en HM "+next1);
                next1 = next1.trim();
                if (collection.get(next1) != null) {
                    // Sólo puede tener un valor
                    String coll2use = collection.get(next1);
                    SWBDataSource dscoll = engine.getDataSource(coll2use);

                    if (null != dscoll) {
                        try {
                            DataObject r = new DataObject();
                            DataObject data = new DataObject();
                            r.put("data", data);
                            data.put("value", obj);
                            DataObject ret = dscoll.fetch(r);
                            DataList rdata = ret.getDataObject("response").getDataList("data");
                            DataObject res = null;
                            if (!rdata.isEmpty()) {
                                String replaceValue = null;
                                for (int i = 0; i < rdata.size(); i++) {
                                    res = rdata.getDataObject(i);  // DataObject de Replace
                                    if (replaceValue == null) {
                                        replaceValue = "";
                                    }
                                    if (replaceValue.length() > 0) {
                                        replaceValue += ",";
                                    }
                                    replaceValue += res.getString("replace");
                                }
                                dobj.put(next1, replaceValue);
                            } else {
                                //System.out.println("No se encomnró valor "+obj+" en la colección..."+coll2use);
                            }
                        } catch (Exception e) {
                            //No se encontró la propiedad con el valor actual
                            log.error("Error al buscar el valor en la colección", e);
                        }

                    }
                }
                //hm.put(next1, next1);
            }
        }
//        return hm;
    }

    /**
     * Carga la colección de Replace a un HashMap<ocurrencia, reemplazo>
     *
     * @param engine Utilizado para poder cargar la colección de Replace en un
     * HashMap
     * @return HashMap con DataSource cargado en memoria.
     */
    public static HashMap<String, String> loadExtractorMapTable(SWBScriptEngine engine, DataObject extDef) {
        HashMap<String, String> hm = new HashMap();
        try {
            SWBDataSource dsMDef = engine.getDataSource("MapDefinition");
            DataObject doMDef = dsMDef.fetchObjById(extDef.getString("mapDef"));
            SWBDataSource ds = engine.getDataSource("MapTable");

            if (null != engine && extDef != null) {
                try {
                    DataList dl = doMDef.getDataList("mapTable");
                    if (null != dl && dl.size() > 0) {
                        //System.out.println("MapTable");
                        for (int i = 0; i < dl.size(); i++) {
                            String llave = dl.getString(i);
                            DataObject dobj = ds.fetchObjById(llave);
                            if (null != dobj) {
                                //System.out.println("("+dobj.getString("property")+","+dobj.getString("collName")+")");
                                hm.put(dobj.getString("property"), dobj.getString("collName"));
                            }
                        }
                    }

                } catch (Exception e) {
                    log.error("Error al cargar el DataSource. ", e);
                }
            } else {
                log.error("Error al cargar el DataSource al HashMap, falta inicializar el engine.");
                return null;
            }
        } catch (Exception ex) {
            log.error(ex);
        }

        return hm;
    }
    
    /**
     * Replaces accented characters and blank spaces in the string given. Makes
     * the changes in a case sensitive manner, the following are some examples
     * of the changes this method makes: <br>
     *
     * @param txt a string in which the characters are going to be replaced
     * @param replaceSpaces a {@code boolean} indicating if blank spaces are
     * going to be replaced or not
     * @return a string similar to {@code txt} but with neither accented or
     * special characters nor symbols in it. un objeto string similar a
     * {@code txt} pero sin caracteres acentuados o especiales y sin
     * s&iacute;mbolos {@literal Á} is replaced by {@literal A} <br>
     * {@literal Ê} is replaced by {@literal E} <br> {@literal Ï} is replaced by
     * {@literal I} <br> {@literal â} is replaced by {@literal a} <br>
     * {@literal ç} is replaced by {@literal c} <br> {@literal ñ} is replaced by
     * {@literal n} <br>
     * and blank spaces are replaced by underscore characters, any symbol in
     * {@code txt} other than underscore is eliminated including the periods.
     * <p>
     * Reemplaza caracteres acentuados y espacios en blanco en {@code txt}.
     * Realiza los cambios respetando caracteres en may&uacute;sculas o
     * min&uacute;sculas los caracteres en blanco son reemplazados por guiones
     * bajos, cualquier s&iacute;mbolo diferente a gui&oacute;n bajo es
     * eliminado.</p>
     */
    public static String replaceSpecialCharacters(String txt, boolean replaceSpaces) {
        StringBuffer ret = new StringBuffer();
        String aux = txt;
        //aux = aux.toLowerCase();
        aux = aux.replace('Á', 'A');
        aux = aux.replace('Ä', 'A');
        aux = aux.replace('Å', 'A');
        aux = aux.replace('Â', 'A');
        aux = aux.replace('À', 'A');
        aux = aux.replace('Ã', 'A');

        aux = aux.replace('É', 'E');
        aux = aux.replace('Ê', 'E');
        aux = aux.replace('È', 'E');
        aux = aux.replace('Ë', 'E');

        aux = aux.replace('Í', 'I');
        aux = aux.replace('Î', 'I');
        aux = aux.replace('Ï', 'I');
        aux = aux.replace('Ì', 'I');

        aux = aux.replace('Ó', 'O');
        aux = aux.replace('Ö', 'O');
        aux = aux.replace('Ô', 'O');
        aux = aux.replace('Ò', 'O');
        aux = aux.replace('Õ', 'O');

        aux = aux.replace('Ú', 'U');
        aux = aux.replace('Ü', 'U');
        aux = aux.replace('Û', 'U');
        aux = aux.replace('Ù', 'U');

        aux = aux.replace('Ñ', 'N');

        aux = aux.replace('Ç', 'C');
        aux = aux.replace('Ý', 'Y');

        aux = aux.replace('á', 'a');
        aux = aux.replace('à', 'a');
        aux = aux.replace('ã', 'a');
        aux = aux.replace('â', 'a');
        aux = aux.replace('ä', 'a');
        aux = aux.replace('å', 'a');

        aux = aux.replace('é', 'e');
        aux = aux.replace('è', 'e');
        aux = aux.replace('ê', 'e');
        aux = aux.replace('ë', 'e');

        aux = aux.replace('í', 'i');
        aux = aux.replace('ì', 'i');
        aux = aux.replace('î', 'i');
        aux = aux.replace('ï', 'i');

        aux = aux.replace('ó', 'o');
        aux = aux.replace('ò', 'o');
        aux = aux.replace('ô', 'o');
        aux = aux.replace('ö', 'o');

        aux = aux.replace('ú', 'u');
        aux = aux.replace('ù', 'u');
        aux = aux.replace('ü', 'u');
        aux = aux.replace('û', 'u');

        aux = aux.replace('ñ', 'n');

        aux = aux.replace('ç', 'c');
        aux = aux.replace('ÿ', 'y');
        aux = aux.replace('ý', 'y');

        if (replaceSpaces) {
            aux = aux.replace(' ', '_');
        }
        int l = aux.length();
        for (int x = 0; x < l; x++) {
            char ch = aux.charAt(x);
            if ((ch >= '0' && ch <= '9') || (ch >= 'a' && ch <= 'z')
                    || (ch >= 'A' && ch <= 'Z') || ch == '_' || ch == '-') {
                ret.append(ch);
            }
        }
        aux = ret.toString();
        return aux;
    }
    
    public static String toStringHtmlEscape(String str){
        StringBuilder buf=new StringBuilder();
        int c=0;
        int i=str.indexOf("\\u",c);
        while(i>-1)
        {
            buf.append(str.substring(c,i));
            int v=Integer.parseInt(str.substring(i+2,i+6),16);
            buf.append("&#"+v+";");
            c=i+6;
            i=str.indexOf("\\u",c);
        }
        buf.append(str.substring(c));
        return buf.toString();
    }
}
